### 3.1 유니언 타입 ( | )


- 값에 허용된 타입을 두개 이상의 가능한 타입으로 확장하는 것
 

값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우에 코드를 처리하는 개념


### 3.1.1 유니언 타입 선언


- 변수의 초기값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 사용


> 유니언 타입의 선언 순서는 중요하지 않음

```typescript
boolean | number === number | boolean
```


### 3.1.2 유니언 속성


- 값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 **모든 가능한 타입**에 존재하는 멤버 속성에만 접근할 수 있음


### 3.2 내로잉


- 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것


유니언 타입으로 정의된 여러 타입 중 하나의 타입으로 된 값의 속서을 사용하기 위에 코드에서 값이 보다 구체적인 타입 중 하나라는 것을 알리는 과정 → 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것


- 타입 가드: 타입을 좁히는 데 사용할 수 있는 논리적 검사


### 3.2.1 값 할당을 통한 내로잉


- 변수에 유니언 타입 애너테이션이 명시되고 초기값이 주어질 때 값 할당 내로잉이 작동함


### 3.2.2 조건 검사를 통한 내로잉


- 조건문을 통해 변수가 알려진 값과 같은지 확인함


### 3.2.3 typeof 검사를 통한 내로잉


- typeof 연산자를 이용해 타입을 확인함


### 3.3 리터럴 타입


- 원시 타입 값 중 어떤 것이 아닌 **특정 원싯값**으로 알려진 타입


```typescript
const philosopher = "Hypatia";
```


① boolean: true | false

② null과 undefined: 둘 다 자기 자신, 즉, 오직 하나의 리터럴 값만 가짐

③ number: 0 | 1 | 2 | 3 ...

④ string: "" | "a" | "b" | "c" ...


### 3.3.1 리터럴 할당 가능성


- 동일한 원시 타입일지라도 서로 다른 리터럴 타입은 서로 할당할 수 없음


### 3.4 엄격한 null 검사


- stricNullChecks: 엄격한 null 검사를 활성화할지 여부 결정


해당 검사를 활성화해야만 코드가 null 또는 undefined 값으로 인한 오류로부터 안전한지 여부를 쉽게 파악할 수 있음


### 3.4.1 십억 달러의 실수


- 다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템을 가리키는 업계 용어


### 3.4.2 참 검사를 통한 내로잉


- 잠재적인 값 중 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있음


> falsy: false, 0, -0, 0n, "", null, undefined, NaN


### 3.4.3 초깃값이 없는 변수


- 변수 타입에 undefined가 포함되어있는 경우 변수에 값이 할당되기 전에 오류가 발생하지 않음


### 3.5 타입 별칭


```typescript
type Name = type1, ... // 파스칼 케이스로 이름 지정
```


### 3.5.1 타입 별칭은 자바스크립트가 아닙니다


- 타입 별칭은 순전히 타입 시스템에만 존재하므로 런타임 코드에서는 참조할 수 없음


### 3.5.2 타입 별칭 결합


```typescript
type Id = number | string;
type IdMaybe = Id | undefined | null; // === number | string | undefined | null
```